package com.sixt.platform.interview;

import java.util.*;
import java.util.function.Supplier;

/**
 * Task:
 * Let's say I have a database of scripts. Each script has an arbitrary number of dependencies.
 * The dependencies are expressed as a list of scriptIds that need to be executed before a given script.
 * There are no circular dependencies.  I want to come up with an execution plan so
 * that I can run all of the scripts in a sane order.  Below is the script representation.
 *
 * @author dmihalishin@gmail.com
 */
public class VulnerabilityScriptRun {


    /**
     * Processing list of scripts
     *
     * @param nextFromDB the iterator that will give next item from DB to process. {@code be null}
     * @param db         the DB that allow to get {@code VulnerabilityScript} from the DB using ID. Cannot {@code be null}
     */
    public void processingScripts(final Iterator<Integer> nextFromDB, final Map<Integer, VulnerabilityScript> db) {
        final Set<Integer> processed = new HashSet<>();
        final Deque<Integer> stack = new ArrayDeque<>();
        final Supplier<Integer> supplier = () -> {
            final Integer next = stack.poll();
            return next == null ? (nextFromDB.hasNext() ? nextFromDB.next() : null) : next;
        };
        Integer nextId;
        while ((nextId = supplier.get()) != null) {
            if (!processed.contains(nextId)) {
                final VulnerabilityScript script = db.get(nextId);
                if (script.getDependencies().stream().allMatch(processed::contains)) {
                    executeScript(script);
                    processed.add(script.getScriptId());
                } else {
                    if (stack.stream().anyMatch(s -> script.getDependencies().contains(s))) throw new RuntimeException("Circular dependencies found! For " + nextId);
                    stack.push(script.getScriptId());
                    script.getDependencies().forEach(stack::push);
                }
            }
        }
    }

    private void executeScript(final VulnerabilityScript script) {
        System.out.println("Execute " + script.getScriptId());
    }

    public void processingScript(final LinkedList<Integer> nextFromDb, final Map<Integer, VulnerabilityScript> db) {
        // Create an empty list
        List<Integer> list = new ArrayList<>();
        final Set<Integer> processed = new HashSet<>();
        Deque<String> deque = new LinkedList<String>();
        // Add each element of iterator to the List

        List<Integer> procesados = new ArrayList<>();


        for (Integer scriptId: nextFromDb) {
            if (!procesados.contains(scriptId)) {
                final VulnerabilityScript script = db.get(scriptId);
                if (script.getDependencies().stream().allMatch(procesados::contains)) {
                    executeScript(script);
                    processed.add(script.getScriptId());
                } else {
                    if (procesados.stream().anyMatch(s -> script.getDependencies().contains(s))) throw new RuntimeException("Circular dependencies found! For " + scriptId);
                    procesados.add(script.getScriptId());
                    script.getDependencies().forEach(procesados::add);
                }
            }
        }

    }



    public void process(final LinkedList<Integer> nextFromDb, final Map<Integer, VulnerabilityScript> db) {

        for (Integer id: nextFromDb) {

        }

    }




}